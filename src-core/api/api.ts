/* tslint:disable */
/* eslint-disable */
/**
 * Flapi Hub API
 * Documentation Swagger auto-générée.
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 * AwsDomainResponse (Interface)
 * @export
 * @interface AwsDomainResponse
 */
export interface AwsDomainResponse {
  /**
   *
   * @type {string}
   * @memberof AwsDomainResponse
   */
  domain: string
  /**
   *
   * @type {boolean}
   * @memberof AwsDomainResponse
   */
  isAvailable: boolean
}
/**
 * AwsSubDomainResponse (Interface)
 * @export
 * @interface AwsSubDomainResponse
 */
export interface AwsSubDomainResponse {
  /**
   *
   * @type {string}
   * @memberof AwsSubDomainResponse
   */
  subdomain: string
  /**
   *
   * @type {boolean}
   * @memberof AwsSubDomainResponse
   */
  isAvailable: boolean
}
/**
 * BadRequestResponse (Interface)
 * @export
 * @interface BadRequestResponse
 */
export interface BadRequestResponse {
  /**
   *
   * @type {string}
   * @memberof BadRequestResponse
   */
  code: string
  /**
   *
   * @type {string}
   * @memberof BadRequestResponse
   */
  message: string
}
/**
 * checkDomainAvailabilityValidator (Validator)
 * @export
 * @interface CheckDomainAvailabilityValidator
 */
export interface CheckDomainAvailabilityValidator {
  /**
   *
   * @type {string}
   * @memberof CheckDomainAvailabilityValidator
   */
  domain: string
}
/**
 * checkSubDomainAvailabilityValidator (Validator)
 * @export
 * @interface CheckSubDomainAvailabilityValidator
 */
export interface CheckSubDomainAvailabilityValidator {
  /**
   *
   * @type {string}
   * @memberof CheckSubDomainAvailabilityValidator
   */
  hostedZoneId: string
  /**
   *
   * @type {string}
   * @memberof CheckSubDomainAvailabilityValidator
   */
  subdomain: string
  /**
   *
   * @type {string}
   * @memberof CheckSubDomainAvailabilityValidator
   */
  domain: string
}
/**
 * createNewApplicationValidator (Validator)
 * @export
 * @interface CreateNewApplicationValidator
 */
export interface CreateNewApplicationValidator {
  /**
   *
   * @type {string}
   * @memberof CreateNewApplicationValidator
   */
  customerName: string
  /**
   *
   * @type {string}
   * @memberof CreateNewApplicationValidator
   */
  projectName: string
  /**
   *
   * @type {string}
   * @memberof CreateNewApplicationValidator
   */
  subdomain: string
}
/**
 * HealthCheckDebugInfo (Interface)
 * @export
 * @interface HealthCheckDebugInfo
 */
export interface HealthCheckDebugInfo {
  /**
   *
   * @type {number}
   * @memberof HealthCheckDebugInfo
   */
  pid: number
  /**
   *
   * @type {number}
   * @memberof HealthCheckDebugInfo
   */
  ppid?: number
  /**
   *
   * @type {number}
   * @memberof HealthCheckDebugInfo
   */
  uptime: number
  /**
   *
   * @type {string}
   * @memberof HealthCheckDebugInfo
   */
  version: string
  /**
   *
   * @type {string}
   * @memberof HealthCheckDebugInfo
   */
  platform: string
}
/**
 * HealthCheckItem (Interface)
 * @export
 * @interface HealthCheckItem
 */
export interface HealthCheckItem {
  /**
   *
   * @type {boolean}
   * @memberof HealthCheckItem
   */
  isCached: boolean
  /**
   *
   * @type {string}
   * @memberof HealthCheckItem
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof HealthCheckItem
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof HealthCheckItem
   */
  status: string
}
/**
 * HealthCheckReport (Interface)
 * @export
 * @interface HealthCheckReport
 */
export interface HealthCheckReport {
  /**
   *
   * @type {boolean}
   * @memberof HealthCheckReport
   */
  isHealthy: boolean
  /**
   *
   * @type {string}
   * @memberof HealthCheckReport
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof HealthCheckReport
   */
  finishedAt: string
  /**
   *
   * @type {HealthCheckDebugInfo}
   * @memberof HealthCheckReport
   */
  debugInfo: HealthCheckDebugInfo
  /**
   *
   * @type {Array<HealthCheckItem>}
   * @memberof HealthCheckReport
   */
  checks: Array<HealthCheckItem>
}
/**
 * LoginSuccessResponse (Interface)
 * @export
 * @interface LoginSuccessResponse
 */
export interface LoginSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof LoginSuccessResponse
   */
  token: string
  /**
   *
   * @type {string}
   * @memberof LoginSuccessResponse
   */
  type: string
  /**
   *
   * @type {string}
   * @memberof LoginSuccessResponse
   */
  expiresAt: string
}
/**
 * loginValidator (Validator)
 * @export
 * @interface LoginValidator
 */
export interface LoginValidator {
  /**
   *
   * @type {string}
   * @memberof LoginValidator
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof LoginValidator
   */
  password: string
}
/**
 * MessageResponse (Interface)
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
  /**
   *
   * @type {string}
   * @memberof MessageResponse
   */
  message: string
}
/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  total?: number
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  page?: number
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  perPage?: number
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  currentPage?: number
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  lastPage?: number
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  firstPage?: number
  /**
   *
   * @type {string}
   * @memberof PaginationMeta
   */
  lastPageUrl?: string
  /**
   *
   * @type {string}
   * @memberof PaginationMeta
   */
  firstPageUrl?: string
  /**
   *
   * @type {string}
   * @memberof PaginationMeta
   */
  nextPageUrl?: string
  /**
   *
   * @type {string}
   * @memberof PaginationMeta
   */
  previousPageUrl?: string
}
/**
 * resendNewCodeValidator (Validator)
 * @export
 * @interface ResendNewCodeValidator
 */
export interface ResendNewCodeValidator {
  /**
   *
   * @type {string}
   * @memberof ResendNewCodeValidator
   */
  email: string
}
/**
 * ResultMessageResponse (Interface)
 * @export
 * @interface ResultMessageResponse
 */
export interface ResultMessageResponse {
  /**
   *
   * @type {boolean}
   * @memberof ResultMessageResponse
   */
  success: boolean
  /**
   *
   * @type {string}
   * @memberof ResultMessageResponse
   */
  message: string
}
/**
 * SignUpPayload (Interface)
 * @export
 * @interface SignUpPayload
 */
export interface SignUpPayload {
  /**
   *
   * @type {number}
   * @memberof SignUpPayload
   */
  role_id: number
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  lastname: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  firstname: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  ip_address: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  ip_region: string
  /**
   *
   * @type {string}
   * @memberof SignUpPayload
   */
  currency_code: string
}
/**
 * User (Model)
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  public_id?: number
  /**
   *
   * @type {number}
   * @memberof User
   */
  public_role_id?: number
  /**
   *
   * @type {UserRole}
   * @memberof User
   */
  public_role?: UserRole
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_lastname?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_firstname?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_email?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_currency_code?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_ip_address?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_ip_region?: string
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  public_is_active?: boolean
  /**
   *
   * @type {number}
   * @memberof User
   */
  public_active_code?: number
  /**
   *
   * @type {number}
   * @memberof User
   */
  public_stripe_customer_id?: number
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_created_at?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_updated_at?: string
}
/**
 * UserRole (Model)
 * @export
 * @interface UserRole
 */
export interface UserRole {
  /**
   *
   * @type {number}
   * @memberof UserRole
   */
  public_id?: number
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  public_name?: string
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  public_created_at?: string
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  public_updated_at?: string
}
/**
 * ValidationError (Interface)
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  rule: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  field: string
}
/**
 * ValidationErrorResponse (Interface)
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationError>
}
/**
 * VerifyCodePayload (Interface)
 * @export
 * @interface VerifyCodePayload
 */
export interface VerifyCodePayload {
  /**
   *
   * @type {string}
   * @memberof VerifyCodePayload
   */
  email: string
  /**
   *
   * @type {number}
   * @memberof VerifyCodePayload
   */
  code: number
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Permet de renvoyer le code de vérification du compte   _app/controllers/auth_controller.ts_ - **resendNewCodeVerificationAccount**
     * @summary Renvoyer le code de vérification du compte (resendNewCodeVerificationAccount)
     * @param {ResendNewCodeValidator} [resendNewCodeValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendNewCodeVerificationAccount: async (
      resendNewCodeValidator?: ResendNewCodeValidator,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/resend-code`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(resendNewCodeValidator, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Permet à un utilisateur de se connecter   _app/controllers/auth_controller.ts_ - **signIn**
     * @summary Connexion d\'un utilisateur (signIn)
     * @param {LoginValidator} [loginValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (loginValidator?: LoginValidator, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signin`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(loginValidator, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Permet à un utilisateur de se déconnecter   _app/controllers/auth_controller.ts_ - **signOut**
     * @summary Déconnexion d\'un utilisateur (signOut)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/auth_controller.ts_ - **signUp**
     * @summary Inscription d\'un utilisateur (signUp)
     * @param {SignUpPayload} [signUpPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp: async (signUpPayload?: SignUpPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signup`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(signUpPayload, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Permet de vérifier le compte utilisateur avec un code   _app/controllers/auth_controller.ts_ - **verifyCode**
     * @summary Vérification du compte utilisateur avec code (verifyCode)
     * @param {VerifyCodePayload} [verifyCodePayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCode: async (
      verifyCodePayload?: VerifyCodePayload,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verifycode`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(verifyCodePayload, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Permet de renvoyer le code de vérification du compte   _app/controllers/auth_controller.ts_ - **resendNewCodeVerificationAccount**
     * @summary Renvoyer le code de vérification du compte (resendNewCodeVerificationAccount)
     * @param {ResendNewCodeValidator} [resendNewCodeValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resendNewCodeVerificationAccount(
      resendNewCodeValidator?: ResendNewCodeValidator,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resendNewCodeVerificationAccount(
        resendNewCodeValidator,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.resendNewCodeVerificationAccount']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Permet à un utilisateur de se connecter   _app/controllers/auth_controller.ts_ - **signIn**
     * @summary Connexion d\'un utilisateur (signIn)
     * @param {LoginValidator} [loginValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(
      loginValidator?: LoginValidator,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(loginValidator, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AuthApi.signIn']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Permet à un utilisateur de se déconnecter   _app/controllers/auth_controller.ts_ - **signOut**
     * @summary Déconnexion d\'un utilisateur (signOut)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signOut(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AuthApi.signOut']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/auth_controller.ts_ - **signUp**
     * @summary Inscription d\'un utilisateur (signUp)
     * @param {SignUpPayload} [signUpPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signUp(
      signUpPayload?: SignUpPayload,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpPayload, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AuthApi.signUp']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Permet de vérifier le compte utilisateur avec un code   _app/controllers/auth_controller.ts_ - **verifyCode**
     * @summary Vérification du compte utilisateur avec code (verifyCode)
     * @param {VerifyCodePayload} [verifyCodePayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyCode(
      verifyCodePayload?: VerifyCodePayload,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCode(verifyCodePayload, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.verifyCode']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Permet de renvoyer le code de vérification du compte   _app/controllers/auth_controller.ts_ - **resendNewCodeVerificationAccount**
     * @summary Renvoyer le code de vérification du compte (resendNewCodeVerificationAccount)
     * @param {ResendNewCodeValidator} [resendNewCodeValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendNewCodeVerificationAccount(
      resendNewCodeValidator?: ResendNewCodeValidator,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .resendNewCodeVerificationAccount(resendNewCodeValidator, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Permet à un utilisateur de se connecter   _app/controllers/auth_controller.ts_ - **signIn**
     * @summary Connexion d\'un utilisateur (signIn)
     * @param {LoginValidator} [loginValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(loginValidator?: LoginValidator, options?: RawAxiosRequestConfig): AxiosPromise<LoginSuccessResponse> {
      return localVarFp.signIn(loginValidator, options).then((request) => request(axios, basePath))
    },
    /**
     * Permet à un utilisateur de se déconnecter   _app/controllers/auth_controller.ts_ - **signOut**
     * @summary Déconnexion d\'un utilisateur (signOut)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut(options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
      return localVarFp.signOut(options).then((request) => request(axios, basePath))
    },
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/auth_controller.ts_ - **signUp**
     * @summary Inscription d\'un utilisateur (signUp)
     * @param {SignUpPayload} [signUpPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp(signUpPayload?: SignUpPayload, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
      return localVarFp.signUp(signUpPayload, options).then((request) => request(axios, basePath))
    },
    /**
     * Permet de vérifier le compte utilisateur avec un code   _app/controllers/auth_controller.ts_ - **verifyCode**
     * @summary Vérification du compte utilisateur avec code (verifyCode)
     * @param {VerifyCodePayload} [verifyCodePayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCode(verifyCodePayload?: VerifyCodePayload, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
      return localVarFp.verifyCode(verifyCodePayload, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi {
  /**
   * Permet de renvoyer le code de vérification du compte   _app/controllers/auth_controller.ts_ - **resendNewCodeVerificationAccount**
   * @summary Renvoyer le code de vérification du compte (resendNewCodeVerificationAccount)
   * @param {ResendNewCodeValidator} [resendNewCodeValidator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public static async resendNewCodeVerificationAccount(
    resendNewCodeValidator?: ResendNewCodeValidator,
    options?: RawAxiosRequestConfig,
  ) {
    const localVarAxiosArgs = await AuthApiAxiosParamCreator().resendNewCodeVerificationAccount(
      resendNewCodeValidator,
      options,
    )
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }

  /**
   * Permet à un utilisateur de se connecter   _app/controllers/auth_controller.ts_ - **signIn**
   * @summary Connexion d\'un utilisateur (signIn)
   * @param {LoginValidator} [loginValidator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public static async signIn(loginValidator?: LoginValidator, options?: RawAxiosRequestConfig) {
    const localVarAxiosArgs = await AuthApiAxiosParamCreator().signIn(loginValidator, options)
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }

  /**
   * Permet à un utilisateur de se déconnecter   _app/controllers/auth_controller.ts_ - **signOut**
   * @summary Déconnexion d\'un utilisateur (signOut)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public static async signOut(options?: RawAxiosRequestConfig) {
    const localVarAxiosArgs = await AuthApiAxiosParamCreator().signOut(options)
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }

  /**
   * Returns **201** (Created) as **application/json**   _app/controllers/auth_controller.ts_ - **signUp**
   * @summary Inscription d\'un utilisateur (signUp)
   * @param {SignUpPayload} [signUpPayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public static async signUp(signUpPayload?: SignUpPayload, options?: RawAxiosRequestConfig) {
    const localVarAxiosArgs = await AuthApiAxiosParamCreator().signUp(signUpPayload, options)
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }

  /**
   * Permet de vérifier le compte utilisateur avec un code   _app/controllers/auth_controller.ts_ - **verifyCode**
   * @summary Vérification du compte utilisateur avec code (verifyCode)
   * @param {VerifyCodePayload} [verifyCodePayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public static async verifyCode(verifyCodePayload?: VerifyCodePayload, options?: RawAxiosRequestConfig) {
    const localVarAxiosArgs = await AuthApiAxiosParamCreator().verifyCode(verifyCodePayload, options)
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }
}

/**
 * AwsDomainApi - axios parameter creator
 * @export
 */
export const AwsDomainApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Vérifie si un domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkDomainAvailability**
     * @summary Vérifie la disponibilité d\'un domaine (checkDomainAvailability)
     * @param {CheckDomainAvailabilityValidator} [checkDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDomainAvailability: async (
      checkDomainAvailabilityValidator?: CheckDomainAvailabilityValidator,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/aws/domain/check`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkDomainAvailabilityValidator,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vérifie si un sous-domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkSubDomainAvailability**
     * @summary Vérifie la disponibilité d\'un sous-domaine (checkSubDomainAvailability)
     * @param {CheckSubDomainAvailabilityValidator} [checkSubDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkSubDomainAvailability: async (
      checkSubDomainAvailabilityValidator?: CheckSubDomainAvailabilityValidator,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/aws/subdomain/check`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkSubDomainAvailabilityValidator,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AwsDomainApi - functional programming interface
 * @export
 */
export const AwsDomainApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AwsDomainApiAxiosParamCreator(configuration)
  return {
    /**
     * Vérifie si un domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkDomainAvailability**
     * @summary Vérifie la disponibilité d\'un domaine (checkDomainAvailability)
     * @param {CheckDomainAvailabilityValidator} [checkDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkDomainAvailability(
      checkDomainAvailabilityValidator?: CheckDomainAvailabilityValidator,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AwsDomainResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailability(
        checkDomainAvailabilityValidator,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AwsDomainApi.checkDomainAvailability']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vérifie si un sous-domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkSubDomainAvailability**
     * @summary Vérifie la disponibilité d\'un sous-domaine (checkSubDomainAvailability)
     * @param {CheckSubDomainAvailabilityValidator} [checkSubDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkSubDomainAvailability(
      checkSubDomainAvailabilityValidator?: CheckSubDomainAvailabilityValidator,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AwsSubDomainResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkSubDomainAvailability(
        checkSubDomainAvailabilityValidator,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AwsDomainApi.checkSubDomainAvailability']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AwsDomainApi - factory interface
 * @export
 */
export const AwsDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AwsDomainApiFp(configuration)
  return {
    /**
     * Vérifie si un domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkDomainAvailability**
     * @summary Vérifie la disponibilité d\'un domaine (checkDomainAvailability)
     * @param {CheckDomainAvailabilityValidator} [checkDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDomainAvailability(
      checkDomainAvailabilityValidator?: CheckDomainAvailabilityValidator,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AwsDomainResponse> {
      return localVarFp
        .checkDomainAvailability(checkDomainAvailabilityValidator, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vérifie si un sous-domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkSubDomainAvailability**
     * @summary Vérifie la disponibilité d\'un sous-domaine (checkSubDomainAvailability)
     * @param {CheckSubDomainAvailabilityValidator} [checkSubDomainAvailabilityValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkSubDomainAvailability(
      checkSubDomainAvailabilityValidator?: CheckSubDomainAvailabilityValidator,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AwsSubDomainResponse> {
      return localVarFp
        .checkSubDomainAvailability(checkSubDomainAvailabilityValidator, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AwsDomainApi - object-oriented interface
 * @export
 * @class AwsDomainApi
 * @extends {BaseAPI}
 */
export class AwsDomainApi {
  /**
   * Vérifie si un domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkDomainAvailability**
   * @summary Vérifie la disponibilité d\'un domaine (checkDomainAvailability)
   * @param {CheckDomainAvailabilityValidator} [checkDomainAvailabilityValidator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AwsDomainApi
   */
  public static async checkDomainAvailability(
    checkDomainAvailabilityValidator?: CheckDomainAvailabilityValidator,
    options?: RawAxiosRequestConfig,
  ) {
    const localVarAxiosArgs = await AwsDomainApiAxiosParamCreator().checkDomainAvailability(
      checkDomainAvailabilityValidator,
      options,
    )
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }

  /**
   * Vérifie si un sous-domaine est disponible via AWS Route 53 Domains   _app/controllers/aws_domain_controller.ts_ - **checkSubDomainAvailability**
   * @summary Vérifie la disponibilité d\'un sous-domaine (checkSubDomainAvailability)
   * @param {CheckSubDomainAvailabilityValidator} [checkSubDomainAvailabilityValidator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AwsDomainApi
   */
  public static async checkSubDomainAvailability(
    checkSubDomainAvailabilityValidator?: CheckSubDomainAvailabilityValidator,
    options?: RawAxiosRequestConfig,
  ) {
    const localVarAxiosArgs = await AwsDomainApiAxiosParamCreator().checkSubDomainAvailability(
      checkSubDomainAvailabilityValidator,
      options,
    )
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }
}

/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/client_controller.ts_ - **createNewApplication**
     * @summary Créer une nouvelle application (createNewApplication)
     * @param {CreateNewApplicationValidator} [createNewApplicationValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewApplication: async (
      createNewApplicationValidator?: CreateNewApplicationValidator,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/client/app/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createNewApplicationValidator,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/client_controller.ts_ - **createNewApplication**
     * @summary Créer une nouvelle application (createNewApplication)
     * @param {CreateNewApplicationValidator} [createNewApplicationValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewApplication(
      createNewApplicationValidator?: CreateNewApplicationValidator,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultMessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewApplication(
        createNewApplicationValidator,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ClientApi.createNewApplication']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ClientApiFp(configuration)
  return {
    /**
     * Returns **201** (Created) as **application/json**   _app/controllers/client_controller.ts_ - **createNewApplication**
     * @summary Créer une nouvelle application (createNewApplication)
     * @param {CreateNewApplicationValidator} [createNewApplicationValidator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewApplication(
      createNewApplicationValidator?: CreateNewApplicationValidator,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResultMessageResponse> {
      return localVarFp
        .createNewApplication(createNewApplicationValidator, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi {
  /**
   * Returns **201** (Created) as **application/json**   _app/controllers/client_controller.ts_ - **createNewApplication**
   * @summary Créer une nouvelle application (createNewApplication)
   * @param {CreateNewApplicationValidator} [createNewApplicationValidator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public static async createNewApplication(
    createNewApplicationValidator?: CreateNewApplicationValidator,
    options?: RawAxiosRequestConfig,
  ) {
    const localVarAxiosArgs = await ClientApiAxiosParamCreator().createNewApplication(
      createNewApplicationValidator,
      options,
    )
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * The application is healthy   _app/controllers/health_controller.ts_ - **health**
     * @summary Check the health of the application (health)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
  return {
    /**
     * The application is healthy   _app/controllers/health_controller.ts_ - **health**
     * @summary Check the health of the application (health)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async health(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckReport>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.health(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['HealthApi.health']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HealthApiFp(configuration)
  return {
    /**
     * The application is healthy   _app/controllers/health_controller.ts_ - **health**
     * @summary Check the health of the application (health)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckReport> {
      return localVarFp.health(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi {
  /**
   * The application is healthy   _app/controllers/health_controller.ts_ - **health**
   * @summary Check the health of the application (health)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public static async health(options?: RawAxiosRequestConfig) {
    const localVarAxiosArgs = await HealthApiAxiosParamCreator().health(options)
    return globalAxios.request({
      ...localVarAxiosArgs.options,
      url: BASE_PATH + localVarAxiosArgs.url,
    })
  }
}
